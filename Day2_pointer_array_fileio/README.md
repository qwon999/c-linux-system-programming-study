# Day2 학습 정리: 포인터와 배열, 파일 시스템의 문

## 🎯 학습 목표

* C언어에서 포인터와 배열의 문법적, 개념적 관계를 설명 가능.
* 포인터 연산을 이용하여 메모리상의 연속된 데이터를 효율적으로 순회 가능.
* 리눅스의 파일 디스크립터(File Descriptor) 기반 파일 I/O 시스템 콜의 동작 원리를 이해.
* `open`, `read`, `write`, `close`를 사용하여 기본적인 파일 처리 프로그램을 작성하고, 파일 권한 및 오류 처리를 수행할 수 있음.

---

## 1. 포인터와 배열: 경계를 허물다

C언어에서 포인터와 배열은 본질적으로 매우 밀접한 관계를 가짐.

* **배열의 이름은 곧 주소:** 배열의 이름은 해당 배열의 첫 번째 요소의 메모리 주소를 가리키는 **상수 포인터**임. `arr`와 `&arr[0]`는 동일한 주소를 나타냄.
* **문법적 등가성:** `arr[i]`는 내부적으로 `*(arr + i)`라는 포인터 연산으로 처리됨.
* **포인터 연산:** 포인터 변수에 `++` 또는 `--` 연산을 할 경우, 포인터가 가리키는 자료형의 크기만큼 주소 값이 증감함. 이를 통해 배열 순회가 가능.
* **C-style 문자열(`char *`)**: `char`형 배열이며, 문자열의 끝은 항상 널(Null) 문자 `\0`로 표시됨. `strlen`, `strcpy` 등의 표준 함수들은 이 널 문자를 기준으로 동작함.

**[실습 확인]** `my_string_test.c` 과제를 통해, `string.h` 라이브러리 없이 오직 포인터 연산만으로 `strlen`, `strcpy`의 핵심 기능을 구현함. 이 과정에서 `*p`와 `p`의 차이를 명확히 이해하고, `while(*p != '\0')`와 같은 조건문을 통해 메모리를 순회하는 방식을 체득함.

---

## 2. 파일 시스템 콜: 운영체제와 직접 소통하기

자바의 `File`, `InputStream`과 같은 추상화된 객체 뒤에 숨겨진, 리눅스 커널과 직접 대화하는 저수준 I/O 방식임.

* **파일 디스크립터(File Descriptor, fd):**
    * 운영체제가 열려있는 파일을 식별하기 위해 부여하는 음수가 아닌 정수 번호표.
    * `0` (표준 입력, STDIN), `1` (표준 출력, STDOUT), `2` (표준 에러, STDERR)는 기본 할당.
* **`open()`:**
    * 파일을 열거나 생성하여 파일 디스크립터를 반환. 실패 시 -1 반환.
    * `flags`: `O_RDONLY` (읽기), `O_WRONLY` (쓰기), `O_CREAT` (생성), `O_TRUNC` (내용 삭제 후 쓰기) 등을 `|` 연산자로 조합하여 파일 열기 모드 지정.
    * `mode`: `O_CREAT` 사용 시, 생성될 파일의 접근 권한을 8진수로 지정.

### ※ `0644` 권한의 의미

리눅스 파일 권한은 세 그룹(소유자, 그룹, 기타 사용자)에 대해 세 가지 권한(읽기, 쓰기, 실행)을 설정함.

* **권한과 숫자:**
    * `읽기(Read)` = 4
    * `쓰기(Write)` = 2
    * `실행(Execute)` = 1
* **숫자 조합:** 각 그룹의 권한은 이 숫자들의 합으로 표현됨.
    * `6` = 4 (읽기) + 2 (쓰기)  ->  `rw-`
    * `4` = 4 (읽기)            ->  `r--`
* **`0644` 해석:**
    * 맨 앞의 `0`: 8진수 표기법을 의미함.
    * `6` (소유자): 읽기(4)와 쓰기(2) 권한을 가짐.
    * `4` (그룹): 읽기(4) 권한만 가짐.
    * `4` (기타): 읽기(4) 권한만 가짐.
    * **결론: "파일 주인은 읽고 쓸 수 있지만, 다른 모든 사용자는 읽기만 가능하다"** 라는, 가장 표준적인 파일 생성 권한임.

* **`read()` / `write()` / `close()`:**
    * `read`/`write`는 fd를 통해 데이터를 읽고 쓰며, 실제 처리된 바이트 수를 반환.
    * `close`는 사용한 fd를 시스템에 명시적으로 반납. 미호출 시 자원 누수 발생.
* **오류 처리:** 시스템 콜 실패 시 `-1`을 반환하고, 전역 변수 `errno`에 오류 코드가 저장됨. `perror()` 함수는 이 `errno`에 해당하는 시스템 오류 메시지를 출력함.

**[실습 확인]**
* `my_cat.c`, `my_cp.c` 구현을 통해 시스템 콜의 흐름을 익힘. 특히 `my_cp`는 두 개의 fd를 동시에 관리하고, `open` 시 권한(`0644`)을 명시하며, 모든 분기에서 오류 처리와 자원 해제를 수행하는 견고한 프로그래밍의 중요성을 학습함.

---

## 📝 주간 회고: 리눅스 환경에서의 C 프로그래밍 경험

**환경 구축, 그 자체로의 학습:** 2주차 학습의 상당 부분은 CLion과 Docker를 연동하여 macOS 위에 완벽한 리눅스 개발 환경을 구축하는 과정이었음. `Dockerfile`을 작성하여 나만의 개발 이미지를 만들고, Toolchain을 설정하며 겪었던 수많은 오류(`Exec format error` 등)와 그 해결 과정은, 단순히 코드를 짜는 것을 넘어 크로스-컴파일 및 원격 개발 환경에 대한 깊은 이해를 제공함. 이 과정 자체가 중요한 시스템 프로그래밍 학습이었음.

**추상화의 이면을 보다:** 자바에서는 JVM이 모든 것을 해결해주었지만, C와 리눅스 환경에서는 아무것도 당연하지 않았음. `open()`으로 파일 디스크립터라는 번호표를 직접 발급받고, `read()`/`write()`로 바이트 단위의 데이터를 옮기며, `close()`로 자원을 명시적으로 반납하는 과정은, `FileInputStream` 한 줄 뒤에 숨겨진 운영체제와의 수많은 상호작용을 체감하게 함.

**개발자의 책임과 권한:** 메모리 관리부터 자원 해제, 오류 처리까지 모든 것이 개발자의 책임으로 돌아옴. `perror()`로 시스템의 목소리를 직접 듣고, `close()`로 뒷정리를 하는 과정은 불편함이 아닌, 시스템을 완전히 제어할 수 있다는 '권한'으로 다가옴. 고수준 언어가 제공하는 편리함의 비용과 저수준 언어가 부여하는 제어권의 가치를 동시에 깨닫는 귀중한 경험이었음.

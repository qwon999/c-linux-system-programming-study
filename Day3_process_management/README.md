# Day3 학습 정리: 프로세스의 탄생과 죽음

## 🎯 학습 목표

* 리눅스에서 프로세스의 생명주기(생성, 실행, 소멸)를 설명 가능.
* `fork()` 시스템 콜의 반환 값 의미와 Copy-on-Write (CoW) 메커니즘을 이해.
* `exec()` 계열 함수를 통해 현재 프로세스를 새로운 프로그램으로 전환 가능.
* `wait()` 시스템 콜을 사용하여 자식 프로세스의 종료를 동기화하고, 좀비 프로세스(Zombie Process)를 방지할 수 있음.
* `fork-exec-wait` 패턴을 활용하여 기본적인 쉘(Shell) 프로그램을 구현 가능.

---

## 1. 프로세스의 탄생: `fork()` 시스템 콜

리눅스에서 새로운 프로세스를 생성하는 전통적인 방식으로, 자기 자신을 복제하는 분신술과 같음.

* **한 번의 호출, 두 번의 반환:** `fork()`는 한 번 호출되지만, 부모와 자식 프로세스 양쪽 모두에게 반환됨.
    * **부모 프로세스:** 자식의 PID(Process ID, 양수)를 반환받음.
    * **자식 프로세스:** `0`을 반환받음.
    * 이 반환 값의 차이를 `if-else`문으로 분기하여 각자의 역할을 수행하도록 코딩함.
* **비결정성 (Non-determinism):** `fork()` 직후 부모와 자식 중 누가 먼저 CPU를 할당받을지는 OS 스케줄러의 결정에 따름. 실행 순서는 보장되지 않으며, `sleep()` 함수 등으로 특정 프로세스를 지연시켜 이 현상을 관찰함.
* **복사-온-쓰기 (Copy-on-Write):** `fork()` 시 메모리를 즉시 복사하지 않고 공유하다가, 부모나 자식 중 누군가 해당 메모리에 쓰기 작업을 시도하는 순간에만 실제 복사가 일어나 효율성을 높이는 기법. `fork_test.c`에서 부모와 자식의 `data` 변수가 서로 영향을 주지 않는 것을 통해 확인.

**[실습 확인]** `fork_test.c`를 통해, `fork()`의 반환 값을 이용하여 부모와 자식 프로세스를 구분하고 각기 다른 코드를 실행하는 방법을 체득함.

---

## 2. 프로세스의 삶: `exec()`과 `wait()`

`fork`로 생성된 자식 프로세스가 의미 있는 작업을 하도록 만드는 핵심 패턴임.

* **`exec()` 계열 함수:**
    * 현재 프로세스의 메모리 공간을 완전히 새로운 프로그램으로 **덮어쓰는** 함수. 한번 성공하면 원래 코드로 돌아오지 않음.
    * `execlp`: 인자를 리스트(`l`)로 나열하고, `PATH` 환경변수(`p`)에서 명령어를 찾음.
    * `execvp`: 인자를 문자열 포인터 배열(`v` for vector)로 받고, `PATH` 환경변수(`p`)에서 명령어를 찾음. 쉘 구현에 가장 적합.
* **`wait()` 시스템 콜:**
    * 부모 프로세스가 자식 프로세스가 종료될 때까지 대기(Blocked)하도록 함.
    * **존재 이유:** 자식이 먼저 종료되면 '좀비 프로세스'가 되어 시스템 자원을 낭비하는 것을 방지. `wait`는 종료된 자식의 정보를 수거하고 시스템에서 깨끗하게 정리하는(reaping) 역할을 수행.
    * `wait(NULL)`: 자식의 종료 상태(exit status) 정보에는 관심 없고, 끝나기를 기다리기만 하겠다는 의미.
* **`fork-exec-wait` 패턴:**
    1.  부모가 `fork()`로 자식을 만든다.
    2.  자식은 `exec()`로 자신을 새로운 프로그램으로 변신시킨다.
    3.  부모는 `wait()`로 자식이 일을 마칠 때까지 기다린다.

**[실습 확인]** `exec_test.c`와 `wait_test.c`를 통해, `wait`가 없는 경우 자식 프로세스의 출력이 유실되는 '고아 프로세스' 문제를 확인하고, `wait`를 통해 이를 해결하여 실행 순서를 보장하는 방법을 학습함.

---

## 3. 종합 실습: 나만의 미니 쉘(Mini Shell) 구현

### 3.1. 안전한 입력 처리: `fgets`

* 사용자 입력을 받을 때, 버퍼 오버플로우와 공백 처리 문제를 가진 `scanf` 대신 `fgets`를 사용.
* `fgets(buf, size, stdin)`: `size`를 지정하여 버퍼 오버플로우를 원천적으로 방지.
* **주의점:** `fgets`는 개행 문자(`\n`)까지 버퍼에 저장하므로, `cmd_buf[strcspn(cmd_buf, "\n")] = '\0';` 코드를 통해 이를 널 문자(`\0`)로 치환하여 제거함.

### 3.2. 문자열 파싱: `strtok`

* 입력받은 명령어 문자열을 공백(" ") 기준으로 잘라내어 명령어와 인자들로 분리.
* `strtok(buf, " ")`를 처음 호출하고, 이후에는 `strtok(NULL, " ")`를 호출하여 다음 토큰을 계속 가져옴.
* 파싱된 토큰(문자열 포인터)들을 `char* args[]` 배열에 순서대로 저장.

### 3.3. 최종 구현

* `while` 루프 안에서 `fgets`로 명령어를 입력받고, `strtok`으로 파싱하여 `args` 배열 생성.
* `args` 배열의 마지막은 `NULL`로 채워 `execvp`에게 인자 목록의 끝을 알림.
* `fork()` 후 자식 프로세스에서 `execvp(args[0], args)`를 호출하여 사용자가 입력한 어떤 명령어든 실행하도록 구현.
* 부모 프로세스는 `waitpid()`로 자식이 끝날 때까지 기다린 후, 다시 다음 명령어를 받을 준비.

**[실습 확인]** `mini_shell.c` 구현을 통해 `ls -al`, `pwd`, `echo hello`, 존재하지 않는 명령어 등 다양한 입력을 처리함. 이를 통해 `fork-exec-wait` 패턴의 실제적인 활용법과, `cd`와 같은 쉘 내장 명령어와의 차이점을 이해함.

---

## 📝 주간 회고

프로세스는 운영체제의 가장 기본적인 실행 단위임을 체감. 자바의 `new ProcessBuilder().start()` 한 줄 뒤에, 리눅스 커널이 `fork`로 프로세스를 복제하고, `exec`으로 프로그램을 덮어씌우며, `wait`로 부모-자식 간의 관계를 정리하는 정교한 과정이 숨어있음을 이해함. 특히, 쉘을 직접 만들며 사용자 입력 처리, 문자열 파싱, 프로세스 제어를 유기적으로 연결하는 경험은 시스템 프로그래밍의 큰 그림을 보는 데 결정적인 계기가 됨.
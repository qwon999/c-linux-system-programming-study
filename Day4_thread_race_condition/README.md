# 4주차 학습 정리: 스레드와 경쟁 조건

## 🎯 학습 목표

* 프로세스와 스레드의 차이점을 메모리 및 자원 공유 관점에서 명확히 설명 가능.
* POSIX 스레드(pthreads) API를 사용하여 스레드를 생성, 실행, 종료 대기 가능.
* 여러 스레드가 공유 자원에 동시 접근 시 발생하는 경쟁 조건(Race Condition)을 코드로 재현하고, 그 원인을 Read-Modify-Write 문제로 설명할 수 있음.
* 동시성 문제 해결의 필요성을 체감하고, 다음 단계 학습(동기화 기법)의 기반을 다짐.

---

## 1. 프로세스 vs. 스레드: 공장과 일꾼들

운영체제의 동시성 모델을 이해하기 위한 가장 근본적인 개념.

| 구분      | 프로세스 (Process)                                | 스레드 (Thread)                                       |
| :-------- | :------------------------------------------------ | :---------------------------------------------------- |
| **비유** | **독립적인 공장** | **공장 안의 일꾼들** |
| **메모리** | 자신만의 독립적인 메모리 공간(Code, Data, Heap, Stack) 소유. | **스택(Stack)을 제외**한 모든 자원(Code, Data, Heap)을 공유. |
| **자원 공유** | IPC(프로세스 간 통신)를 통해서만 가능.            | 직접 공유. (전역 변수, 힙 메모리 등)                  |
| **생성 비용** | 무거움 (메모리 복사 등 오버헤드가 큼)             | 가벼움 (스택과 레지스터만 할당)                       |
| **안정성** | 한 프로세스의 오류가 다른 프로세스에 영향을 주지 않음. | 한 스레드의 오류(예: 잘못된 포인터 접근)가 전체 프로세스를 죽임. |

**[실습 확인]** `pthread_test.c`를 통해, `pthread_create()`로 메인 스레드와 별개의 실행 흐름을 가진 새로운 스레드를 생성함. `pthread_join()`을 사용하여, 메인 스레드가 자식 스레드의 작업이 끝날 때까지 기다리도록 동기화하는 방법을 학습. 이는 `wait()`가 자식 프로세스를 기다리는 것과 유사한 개념임.

---

## 2. 경쟁 조건 (Race Condition): 혼돈의 서막

여러 스레드가 하나의 공유 자원을 동시에 수정하려고 할 때 발생하는 문제.

* **공유 자원 (Shared Resource):** 여러 스레드가 동시에 접근 가능한 변수. (예: 전역 변수 `shared_counter`)
* **임계 구역 (Critical Section):** 공유 자원에 접근하는 코드 영역. (예: `shared_counter++;`)
* **문제의 근원 (Read-Modify-Write):**
  `shared_counter++`와 같은 간단한 연산조차도, 실제 기계어 수준에서는 아래 3단계로 나뉘어 실행됨.
    1.  **Read:** 메모리에서 `shared_counter`의 현재 값을 CPU 레지스터로 읽어온다.
    2.  **Modify:** CPU 레지스터의 값을 1 증가시킨다.
    3.  **Write:** 레지스터의 새로운 값을 다시 메모리에 쓴다.
* **경쟁의 발생:** 스레드 A가 1번(Read)을 수행한 직후, OS 스케줄러에 의해 스레드 B로 컨텍스트 스위칭이 일어날 수 있음. 스레드 B 역시 1번(Read)을 수행하면, 두 스레드는 같은 초기값을 가지고 연산을 시작하게 됨. 그 결과, 한쪽의 증가 연산이 다른 쪽에 의해 덮어씌워져 **갱신이 누락(Lost Update)**됨.

**[실습 확인]** `race_condition_test.c`를 통해, 10개의 스레드가 각각 100만 번씩 공유 카운터를 증가시키는 코드를 실행. 최종 결과가 예상치(10,000,000)에 훨씬 못 미치고, 실행할 때마다 결과가 달라지는 것을 직접 목격함. 이를 통해 동기화 없는 멀티스레딩의 위험성과 예측 불가능성을 체감.

---

## 📝 주간 회고

자바의 `Thread` 클래스와 `synchronized` 키워드가 얼마나 강력한 추상화였는지 깨닫는 한 주였음. C언어와 pthreads를 통해, 스레드가 프로세스의 메모리 공간을 어떻게 공유하는지, 그리고 그 공유 때문에 왜 데이터의 정합성이 쉽게 깨질 수 있는지 근본 원리를 파고듦. 특히 `count++` 연산이 원자적(Atomic)이지 않다는 사실을 인지하고, Read-Modify-Write 사이클의 어느 지점에서든 컨텍스트 스위칭이 발생할 수 있다는 것을 이해한 것이 가장 큰 수확. 이 '혼돈'의 문제를 명확히 인지했으므로, 다음 주에 배울 뮤텍스(Mutex)와 같은 동기화 기법의 필요성을 절실히 느끼게 됨.